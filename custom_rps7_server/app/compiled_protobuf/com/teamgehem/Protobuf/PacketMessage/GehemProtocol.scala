// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!

package com.teamgehem.Protobuf.PacketMessage


import com.trueaccord.scalapb.Descriptors

final case class GehemProtocol(
    packetType: com.teamgehem.Protobuf.PacketMessage.PacketType,
    testList: Seq[Int] = Nil
    ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[GehemProtocol] with com.trueaccord.lenses.Updatable[GehemProtocol] {
    lazy val serializedSize: Int = {
      var __size = 0
      __size += com.google.protobuf.CodedOutputStream.computeEnumSize(1, packetType.id)
      testList.foreach(testList => __size += com.google.protobuf.CodedOutputStream.computeInt32Size(2, testList))
      __size
    }
    def writeTo(output: com.google.protobuf.CodedOutputStream): Unit = {
      output.writeEnum(1, packetType.id)
      testList.foreach { v => 
        output.writeInt32(2, v)
      }
    }
    def mergeFrom(__input: com.google.protobuf.CodedInputStream): com.teamgehem.Protobuf.PacketMessage.GehemProtocol = {
      var __packetType = this.packetType
      val __testList = (scala.collection.immutable.Vector.newBuilder[Int] ++= this.testList)
      var _done__ = false
      while (!_done__) {
        val _tag__ = __input.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 8 =>
            __packetType = com.teamgehem.Protobuf.PacketMessage.PacketType.fromValue(__input.readEnum())
          case 16 =>
            __testList += __input.readInt32()
          case tag => __input.skipField(tag)
        }
      }
      com.teamgehem.Protobuf.PacketMessage.GehemProtocol(
          packetType = __packetType,
          testList = __testList.result()
      )
    }
    def withPacketType(__v: com.teamgehem.Protobuf.PacketMessage.PacketType): GehemProtocol = copy(packetType = __v)
    def clearTestList = copy(testList = Nil)
    def addTestList(__vs: Int*): GehemProtocol = addAllTestList(__vs)
    def addAllTestList(__vs: TraversableOnce[Int]): GehemProtocol = copy(testList = testList ++ __vs)
    def withTestList(__v: Seq[Int]): GehemProtocol = copy(testList = __v)
    def getField(__field: Descriptors.FieldDescriptor): Any = {
      __field.number match {
        case 1 => packetType
        case 2 => testList
      }
    }
    def companion = com.teamgehem.Protobuf.PacketMessage.GehemProtocol
}

object GehemProtocol extends com.trueaccord.scalapb.GeneratedMessageCompanion[GehemProtocol]  {
  implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[GehemProtocol]  = this
  def fromFieldsMap(fieldsMap: Map[Int, Any]): com.teamgehem.Protobuf.PacketMessage.GehemProtocol = com.teamgehem.Protobuf.PacketMessage.GehemProtocol(
    packetType = fieldsMap(1).asInstanceOf[com.teamgehem.Protobuf.PacketMessage.PacketType],
    testList = fieldsMap.getOrElse(2, Nil).asInstanceOf[Seq[Int]]
  )
  lazy val descriptor = new Descriptors.MessageDescriptor("GehemProtocol", this,
    None, m = Seq(),
    e = Seq(),
    f = com.teamgehem.Protobuf.PacketMessage.InternalFields_packetMessageProto.internalFieldsFor("com.teamgehem.Protobuf.PacketMessage.GehemProtocol"))
  lazy val defaultInstance = com.teamgehem.Protobuf.PacketMessage.GehemProtocol(
    packetType = com.teamgehem.Protobuf.PacketMessage.PacketType.NONE
  )
  implicit class GehemProtocolLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, GehemProtocol]) extends com.trueaccord.lenses.ObjectLens[UpperPB, GehemProtocol](_l) {
    def packetType: com.trueaccord.lenses.Lens[UpperPB, com.teamgehem.Protobuf.PacketMessage.PacketType] = field(_.packetType)((c_, f_) => c_.copy(packetType = f_))
    def testList: com.trueaccord.lenses.Lens[UpperPB, Seq[Int]] = field(_.testList)((c_, f_) => c_.copy(testList = f_))
  }
  final val PACKETTYPE_FIELD_NUMBER = 1
  final val TESTLIST_FIELD_NUMBER = 2
}
